LOST CITATIONS

# Foundation Model Paradigm {#sec-ch10-fm-principles}

The deep learning era in genomics began with fragmentation. One convolutional network predicted transcription factor binding; another predicted chromatin accessibility; a third classified splice sites. Each model required its own training data, its own hyperparameter tuning, its own validation strategy. A laboratory studying gene regulation might train a dozen specialized models, none of which could inform the others. Knowledge learned for predicting enhancer activity provided no benefit for predicting splicing outcomes, even though both tasks depend on recognizing sequence patterns shaped by the same evolutionary pressures. The field accumulated tools without accumulating shared knowledge.

**Foundation models** promise a different approach: train once on vast genomic data, then adapt to many downstream tasks. A single model pretrained on billions of nucleotides might provide representations useful for regulatory prediction, variant interpretation, sequence design, and cross-species analysis simultaneously. Rather than curating labeled datasets for each new question, researchers could fine-tune existing models on modest task-specific data, leveraging knowledge the model acquired during **pretraining**. The efficiency gains would be substantial; the conceptual shift would be larger still. Where specialized models treat each genomic question as independent, foundation models assume that shared patterns underlie diverse biological phenomena and that representations capturing those patterns should transfer.

This paradigm, which transformed natural language processing and protein structure prediction, carries both promise and peril for genomics. Pretraining at scale requires computational resources beyond most academic budgets. Adaptation to specific tasks demands expertise in **transfer learning** techniques that remain poorly understood (@sec-ch09-transfer). Predictions from general-purpose models may lack the precision of specialized alternatives trained directly on task-specific data. The decision to use, adapt, or build foundation models involves tradeoffs that depend on available resources, target applications, and acceptable uncertainty.


## From Task-Specific Models to Foundation Models {#sec-ch10-task-specific}

The history of computational genomics reveals a consistent pattern: models become more general while maintaining or improving task-specific performance. Hand-crafted scores such as *CADD* and *SIFT* established that integration of diverse genomic annotations could improve variant pathogenicity prediction (@sec-ch04-vep-classical). These approaches relied on expert feature engineering, combining conservation scores, functional annotations, and population frequency data through ensemble methods or logistic regression.

Task-specific deep learning models demonstrated that neural networks could learn relevant features directly from sequence. *DeepSEA* predicted chromatin accessibility and transcription factor binding from 1 kb sequences using convolutional architectures. *ExPecto* extended this approach to gene expression prediction by modeling regulatory elements across multiple cell types. *Sei* organized regulatory predictions into interpretable sequence classes through unsupervised clustering. *SpliceAI* achieved near-perfect splice site prediction through dilated convolutions over 10 kb contexts (@sec-ch06-cnn). *Enformer* scaled sequence-to-function modeling to 200 kb windows and thousands of chromatin tracks through transformer architectures.

These models succeeded within their specific domains but remained difficult to repurpose. Training a *DeepSEA* model required chromatin accessibility data. Using *SpliceAI* for regulatory prediction would require complete retraining on different labels. Each application domain needed its own model, trained from scratch on task-specific data. The fundamental limitation was not model capacity but training paradigm: supervised learning on narrow tasks produced narrow capabilities.

::: {#fig-paradigm-shift layout-ncol=2}
![**FIGURE PLACEHOLDER A**](https://placehold.co/300x200?text=FIGURE%20PLACEHOLDER%20A)

![**FIGURE PLACEHOLDER B**](https://placehold.co/300x200?text=FIGURE%20PLACEHOLDER%20B)

[Essential] Two-panel comparison showing the paradigm shift. Panel A (Task-Specific Era): Multiple independent models (*DeepSEA*, *SpliceAI*, *ExPecto*) shown as separate pipelines, each with its own training data, architecture, hyperparameters; arrows showing no knowledge transfer between models; Label: "Train separately, no shared learning." Panel B (Foundation Model Era): Single large pretrained backbone at center, multiple lightweight adaptation heads branching out, downstream tasks (regulatory, splicing, expression, variant effect) as leaf nodes, shared representation layer highlighted; Label: "Pretrain once, adapt many."
:::

Sequence language models introduced the self-supervised pretraining paradigm (@sec-ch08-pretraining) to genomics. *DNABERT* applied **masked language modeling** to DNA sequences, demonstrating that general representations could be learned without task-specific labels. *ESM* and *ESM-2* showed that protein language models pretrained on sequence alone could transfer effectively to structure prediction, variant effect prediction, and protein design (@sec-ch12-protein-lm). The *Nucleotide Transformer* family scaled DNA language modeling to cross-species training corpora (@sec-ch11-dna-lm). *HyenaDNA* used implicit convolutions to reach million-token contexts at single-nucleotide resolution.

The transition from task-specific to foundation models changes the relationship between model developers and users. Task-specific models deliver predictions as their primary product. Foundation models deliver representations that users adapt to their own tasks through the transfer learning techniques examined in @sec-ch09-transfer. This distinction affects everything from model architecture design to evaluation strategies to deployment infrastructure.


## Defining Genomic Foundation Models {#sec-ch10-defining}

The term "foundation model" appears frequently in genomics literature, sometimes applied to any large neural network trained on biological sequences. Establishing clear criteria helps separate true genomic foundation models from ordinary deep learning approaches that happen to operate on DNA or protein sequences.


### Essential Properties {#sec-ch10-essential-properties}

The defining characteristic of genomic foundation models is their capacity to serve purposes far beyond their original training objectives. This generality emerges from several interconnected properties.

Foundation models train on entire genomes, pan-genomic sequence collections, or large assay compendia with minimal supervision. Their pretraining objectives include masked language modeling, next-token prediction, denoising, or multi-task sequence-to-function prediction. Critically, these objectives do not require dense task-specific labels for every training example. A model that requires annotated enhancers or curated pathogenic variants for every training instance does not qualify as a foundation model under this criterion.

The representations these models produce must prove useful across many downstream tasks. **Embeddings** can be extracted through forward passes and reused with simple linear probes or lightweight adapter modules rather than requiring full model retraining. The representations should encode biological information at multiple scales, from local sequence motifs to long-range regulatory grammar.

Transfer capability extends across multiple dimensions: different assays (from chromatin accessibility to gene expression), different tissues and cell types, different species, and different variant types (from SNVs to structural variants). Evidence of broad transfer requires evaluation across multiple benchmarks rather than demonstration of performance on a single task (@sec-ch20-benchmarks).

Foundation models operate at a scale that would be impractical for task-specific training. Some scale context length, as *HyenaDNA* scales to million-token windows at single-nucleotide resolution. Others scale parameter count, as the *ESM* and *Nucleotide Transformer* families reach billions of parameters. Still others scale data diversity through pan-genomic pretraining across hundreds of species or integration of many assays and cell types. The scaling dimension chosen reflects the model's intended applications and architectural constraints.

Finally, foundation models typically expose consistent APIs for common operations. These include embedding extraction for sequences or variants, sequence probability scoring, and mask-based *in silico* mutagenesis for variant effect prediction. Models distributed through repositories such as Hugging Face often include documented recipes for downstream **fine-tuning** and example notebooks demonstrating common use cases.


### What Doesn't Count {#sec-ch10-what-doesnt-count}

Many excellent genomic models fail one or more of these criteria and should not be classified as foundation models. Early versions of *DeepSEA* trained specifically on chromatin accessibility data from a limited set of cell types lack the generality and standardized interface of foundation models, though later iterations that integrate many assays begin to approach foundation model territory. *SpliceAI* predicts splicing outcomes exceptionally well but was designed for that specific task and provides neither general-purpose embeddings nor easy transfer to other genomic prediction problems. Even a very large *Enformer*-like model trained solely on human chromatin tracks remains bound to its specific prediction interface despite its scale and sophistication.

The distinction matters for several reasons. It affects evaluation strategy, since foundation models must be assessed across families of tasks rather than single benchmarks (@sec-ch21-eval). It affects integration into existing pipelines, since foundation models serve as feature extractors while task-specific models typically provide end-to-end predictions. It affects how we think about model development, since foundation model training requires different infrastructure and data curation than task-specific supervised learning.


### Limitations of the Foundation Model Concept {#sec-ch10-concept-limitations}

The term "foundation" carries implications worth examining. Architectural foundations are static, load-bearing, and invisible once construction proceeds. Genomic foundation models share only the load-bearing property: they support downstream applications that would otherwise require independent construction. Yet unlike architectural foundations, these models remain visible and modifiable throughout their use. Fine-tuning adjusts the foundation itself rather than building atop an immutable base. The metaphor also implies that foundations precede and enable all subsequent work, but genomic foundation models often coexist with task-specific alternatives that outperform them on narrow benchmarks.

A more accurate metaphor might be "foundation" in the educational sense: a broad base of knowledge that enables specialized learning but continues to develop alongside it. The pretraining phase establishes general competence; adaptation refines that competence for specific purposes without abandoning the original learning. This framing better captures the dynamic relationship between pretrained representations and downstream tasks, though the architectural metaphor has become standard terminology.


## Scaling Laws and Compute-Optimal Training {#sec-ch10-scaling}

The success of foundation models in natural language processing rests partly on empirical **scaling laws**: predictable relationships between model size, training data, computational budget, and performance. Understanding these relationships guides resource allocation and model development decisions.


### Scaling Law Framework {#sec-ch10-scaling-framework}

Scaling laws describe how model performance (typically measured as loss on held-out data) varies with three key quantities: the number of model parameters (*N*), the amount of training data (*D*), and the total compute budget (*C*). The Chinchilla scaling analysis demonstrated that for a fixed compute budget, there exists an optimal balance between model size and training data. Training a model that is too large on too little data, or too small on too much data, yields worse performance than compute-optimal allocation. *[Citation Needed]*

The practical implications are significant. Many early large language models were undertrained relative to their parameter count. GPT-3's 175 billion parameters were trained on roughly 300 billion **tokens**, while Chinchilla-optimal training would suggest either fewer parameters or more data. The Chinchilla model itself matched GPT-3 performance with only 70 billion parameters trained on 1.4 trillion tokens. *[Citation Needed]*

For genomic foundation models, scaling relationships are less well characterized but increasingly important. Several key questions arise: Do genomic sequences exhibit the same scaling behavior as natural language? How does the finite size of reference genomes constrain data scaling? What role does sequence diversity (cross-species, population variation) play in data scaling? Can synthetic data augmentation extend effective training data beyond natural sequences?


### Empirical Scaling in Genomic Models {#sec-ch10-empirical-scaling}

Several genomic foundation model families have reported scaling experiments, though systematic scaling laws comparable to NLP remain elusive.

The *Nucleotide Transformer* family provides perhaps the clearest genomic scaling data. Performance on downstream benchmarks improves consistently with parameter count across models from 50 million to 2.5 billion parameters. The largest models (trained on multi-species data) outperform smaller models trained on human sequences alone, suggesting that cross-species data provides effective scaling even when human-specific performance is the target. Training compute scaled from approximately 10^19 to 10^21 FLOPs across the model family. *[Citation Needed]*

::: {#fig-scaling-laws layout-ncol=3}
![**FIGURE PLACEHOLDER A**](https://placehold.co/300x200?text=FIGURE%20PLACEHOLDER%20A)

![**FIGURE PLACEHOLDER B**](https://placehold.co/300x200?text=FIGURE%20PLACEHOLDER%20B)

![**FIGURE PLACEHOLDER C**](https://placehold.co/300x200?text=FIGURE%20PLACEHOLDER%20C)

[Essential] Three-panel figure illustrating scaling relationships. Panel A (Loss vs. Parameters): Log-log plot showing validation loss decreasing with parameter count; data points from *Nucleotide Transformer* family (50M to 2.5B); *ESM-2* scaling curve overlaid for comparison; power law fit line with exponent annotation. Panel B (Compute-Optimal Frontier): Iso-performance contours on parameter × data plane; Chinchilla optimal line showing balanced allocation; undertrained region shaded; genomic data ceiling annotated (approximately 10^12 nucleotides). Panel C (Emergent Capabilities): Capability (*y*-axis) vs. scale (*x*-axis, log); multiple curves showing different capabilities emerging at different scales; threshold markers where capabilities "switch on."
:::

*ESM-2* demonstrated similar scaling for protein language models, with performance on structure prediction and variant effect tasks improving smoothly from 8 million to 15 billion parameters (@sec-ch12-protein-lm). The largest *ESM-2* models approach the structure prediction accuracy of *AlphaFold2* using only single-sequence input, a capability entirely absent in smaller models. This represents a qualitative capability threshold crossed through scale. *[Citation Needed]*

*HyenaDNA* focused on context length scaling rather than parameter scaling, demonstrating that million-token contexts at single-nucleotide resolution could be achieved through sub-quadratic architectures. The relationship between context length and downstream performance is task-dependent: some tasks (local motif recognition) show saturation at kilobase scales, while others (long-range regulatory prediction) continue improving with longer contexts. *[Citation Needed]*


### Compute-Optimal Decisions for Genomics {#sec-ch10-compute-optimal}

The scaling law framework has direct implications for model development decisions in genomics, though the constraints differ fundamentally from natural language processing.

Unlike natural language, where text data is effectively unlimited, genomic sequence data faces hard constraints. Reference genomes for well-studied species total perhaps 10^11 to 10^12 nucleotides. Population-level variant data can expand this somewhat, but the effective diversity may be lower than raw counts suggest. In such data-constrained regimes, smaller models trained to convergence may outperform larger models that are undertrained.

Academic groups typically face stricter compute constraints than industry labs. Given fixed compute budgets, the Chinchilla framework suggests allocating resources toward longer training of smaller models rather than abbreviated training of larger models. A 500 million parameter model trained for 10 epochs on diverse genomic data may outperform a 5 billion parameter model trained for 1 epoch on the same data.

Cross-species data offers a potential path around genomic data limitations. Training on genomes from hundreds of species provides sequence diversity that human genomes alone cannot. The *Nucleotide Transformer* and *Evo* families exploit this strategy, learning evolutionary patterns from diverse genomes that improve human-specific predictions (@sec-ch11-dna-lm). However, the transfer efficiency from non-human species to human tasks varies by application and remains poorly characterized.


### Emergent Capabilities {#sec-ch10-emergence}

Perhaps the most intriguing aspect of foundation model scaling is the emergence of qualitatively new capabilities at sufficient scale. Emergence refers to abilities that are absent or negligible in smaller models but appear discontinuously as models grow.

In large language models, emergent capabilities include multi-step reasoning, code generation, and in-context learning. These capabilities appear at model scales of roughly 10^10 parameters and above, with no clear precursor in smaller models. *[Citation Needed]*

Genomic foundation models exhibit analogous emergence, though the capability thresholds are less well characterized. The most striking example involves structural understanding from sequence: *ESM-2* at sufficient scale produces contact maps and secondary structure predictions from single sequences with accuracy approaching multiple sequence alignment methods. Smaller *ESM* models show no meaningful structural understanding. This capability emerges at approximately 650 million parameters and continues improving with scale. *[Citation Needed]*

Larger *Nucleotide Transformer* models transfer more effectively to novel species not seen during training. The ability to generalize beyond training species appears to require sufficient model capacity to learn abstract regulatory principles rather than memorizing species-specific patterns. Similarly, foundation models at sufficient scale can predict variant effects without task-specific fine-tuning, using only the difference in likelihood between reference and alternative sequences. This zero-shot capability requires models large enough to capture subtle sequence dependencies.

The most recent genomic foundation models show preliminary evidence of in-context learning: the ability to adapt to new tasks based on examples provided in the input context without parameter updates. This capability, central to the utility of large language models, remains nascent in genomic models but may emerge with further scaling.

The practical implication is that capability thresholds exist: models below certain scales may be fundamentally incapable of certain tasks regardless of fine-tuning. Identifying these thresholds helps guide model selection and prevents wasted effort fine-tuning models that lack necessary capacity.


## A Taxonomy of Genomic Foundation Models {#sec-ch10-taxonomy}

The landscape of genomic foundation models can be organized into four broad families. Each family exhibits distinct characteristics, strengths, limitations, and typical application domains.

::: {#fig-model-taxonomy layout-ncol=2}
![**FIGURE PLACEHOLDER**](https://placehold.co/300x200?text=FIGURE%20PLACEHOLDER)

[Essential] 2×2 grid with families as quadrants. Quadrant 1 (DNA Language Models, Blue): *DNABERT*, *Nucleotide Transformer*, *HyenaDNA*, *Evo 2*. Quadrant 2 (Protein Language Models, Purple): *ESM-2*, *ProtTrans*, *ESMFold*. Quadrant 3 (Sequence-to-Function Models, Green): *Enformer*, *Borzoi*, *AlphaGenome*. Quadrant 4 (Multi-Omic Models, Orange): *Omni-DNA*, cross-modal architectures. For each: representative models, input/output types, pretraining approach, strengths, limitations. Connecting lines showing where models can feed into each other.
:::


### DNA Language Models {#sec-ch10-dna-lm}

DNA language models treat genomic sequence as a language to be modeled, learning representations from raw nucleotide strings through self-supervised objectives. Without explicit functional labels, these models discover patterns through statistical regularities in genomic sequence.

The pretraining objectives typically involve masked language modeling or **autoregressive** next-token prediction. Training draws from reference genomes or pan-genomic sequence collections spanning multiple species. The resulting models produce per-position or pooled sequence embeddings that can be extracted and used for downstream tasks. Critically, these embeddings are not tied to specific assays or cell types, making them applicable to any task that benefits from general sequence context.

*DNABERT* and *DNABERT-2* apply BERT-style masked language modeling to DNA sequences, using overlapping *k*-mers as tokens. The *Nucleotide Transformer* family scales this approach to larger parameter counts and cross-species training. *HyenaDNA* achieves subquadratic complexity through implicit convolutions, enabling context lengths up to one million nucleotides. *Caduceus* incorporates bidirectional processing and reverse-complement equivariance as architectural inductive biases. *Evo-2* combines long-range attention with biological **tokenization** strategies. *GROVER* integrates learned BPE-style tokenization with training on regulatory tracks in addition to raw sequence. Detailed treatment of these models appears in @sec-ch11-dna-lm.

The primary strength of DNA language models lies in their generality: representations not bound to specific assays, cell types, or experimental conditions, capable of processing novel sequences absent from reference genomes. Their self-supervised training requires only genome sequences, making them scalable to massive corpora. The corresponding limitation is that without explicit functional grounding, they may not capture subtle regulatory patterns that manifest only under specific cellular conditions. Performance on tasks requiring fine-grained functional discrimination may lag models trained with functional supervision.

Applications span sequence classification (promoters, enhancers, transposons), motif discovery, variant effect prediction through embedding perturbation, sequence generation for synthetic biology, and transfer learning to new species with limited labeled data.


### Sequence-to-Function Foundation Models {#sec-ch10-seq-to-func}

Sequence-to-function models predict molecular readouts directly from sequence through supervised or semi-supervised training on assay compendia. These models blur into foundation model territory when their output space is sufficiently broad and their internal representations prove useful for tasks beyond the original assay set.

These models map DNA sequences to high-dimensional vectors of molecular measurements, including chromatin accessibility, histone modifications, transcription factor binding, and gene expression levels. Training uses large collections of functional genomics assays spanning many cell types, enabling the models to learn regulatory grammar through supervised prediction of molecular phenotypes.

*Enformer* predicts thousands of chromatin and expression tracks from 200 kb sequence windows through transformer attention (@sec-ch13-regulatory). *Borzoi* extends this with refined architectures and expanded coverage. *Sei* organizes predictions into interpretable sequence classes through unsupervised clustering. Earlier models including *DeepSEA* and *Basset* established the paradigm at smaller scales (@sec-ch06-cnn).

The explicit functional supervision in these models provides mechanistic grounding that pure language models lack. Predictions can be interpreted through comparison to experiments. The models naturally support variant effect prediction by computing reference-alternative differences. The tradeoff is that models remain tied to training assays and cell types; extension to new contexts typically requires retraining or new data collection.

Applications center on regulatory variant interpretation in well-studied cell types, eQTL fine-mapping, enhancer identification, transcription factor binding prediction, and regulatory mechanism discovery.


### Variant Effect Prediction Models {#sec-ch10-vep-models}

The clinical need to interpret genetic variants has driven development of models optimized specifically for predicting functional or clinical consequences. These take a variant and predict its effect on molecular phenotypes, organismal fitness, or disease risk.

Variant effect prediction models integrate sequence context with evolutionary information, population genetics signals, and sometimes structural or functional annotations. They output pathogenicity scores, effect size estimates, or functional consequence predictions. Training combines multiple data sources: clinical labels from ClinVar, population frequency from gnomAD, functional assays such as deep mutational scanning, and evolutionary constraint metrics.

*AlphaMissense* applies protein language models to predict pathogenicity of missense variants. *ESM-1v* uses evolutionary context for protein variant effect prediction. *EVE* combines evolutionary and structural information. Genomic foundation models like *DNABERT* and *Enformer* provide variant effect predictions through *in silico* mutagenesis. The architecture, training, evaluation, and clinical deployment of variant effect predictors are covered comprehensively in @sec-ch14-vep-fm.


### Multi-Omic Foundation Models {#sec-ch10-multi-omic}

The most ambitious foundation models natively integrate multiple molecular modalities, jointly processing DNA sequence, chromatin state, gene expression, protein abundance, 3D genome structure, or phenotypic descriptions.

Multi-omic models employ architectures designed for heterogeneous input types: transformer variants with **cross-attention**, graph neural networks, or modality-specific encoders with fusion layers (@sec-ch07-attention, @sec-ch18-networks). Training objectives encourage cross-modal alignment through contrastive learning, joint prediction, or generative modeling of multiple data types.

*Omni-DNA* uses transformer-based autoregressive models with vocabulary expansion and multi-task finetuning, unifying diverse genomic tasks under an instruction-response paradigm. Models integrating Hi-C data capture 3D genome organization (@sec-ch17-3d-genome). Cross-modal architectures align DNA embeddings with chromatin or expression predictions (@sec-ch19-multi-omics).

The unified representations these models produce enable cross-modal queries, and joint training can improve performance through multi-task effects. Data engineering becomes substantially more complex, however, with different modalities requiring different measurement technologies and quality control. The field is early, with few models reaching production maturity.


## Design Dimensions {#sec-ch10-design-dimensions}

Within and across families, individual models differ along orthogonal design dimensions that affect suitability for specific tasks.


### Data Composition {#sec-ch10-data-composition}

The choice of training data shapes what patterns a model can learn. Training on human sequences alone focuses on clinically relevant patterns but limits exposure to evolutionary diversity. Cross-species training encourages learning of conserved elements and evolutionary constraints, potentially improving generalization but risking dilution of human-specific signals.

Sequence diversity presents a similar tradeoff. Training on reference genomes alone provides clean sequences but limited exposure to population variation. Incorporating variant data improves robustness but requires careful design to avoid learning spurious associations. Models may also train on raw sequence alone or incorporate functional annotations, trading generality against functional grounding. The implications of training data choices for model bias are examined in @sec-ch22-confounding.


### Architecture Choices {#sec-ch10-architecture}

Architectural decisions determine both computational characteristics and inductive biases. Among transformer variants, encoder-only models (*DNABERT*, *Nucleotide Transformer*) excel at classification and embedding tasks, while decoder-only models (*GROVER*) support generative applications (@sec-ch07-attention). Full and sparse attention patterns, linear approximations, and Flash attention implementations affect computational efficiency.

Hyena-based models and state space models achieve subquadratic scaling, enabling longer contexts than standard transformers with comparable parameters. Hybrid approaches combine local convolutions with global attention, as in *Enformer*, processing sequences at multiple resolutions.


### Context Length {#sec-ch10-context-length}

The context window determines what genomic relationships a model can capture. Short context (under 1 kb) captures local patterns: motifs, splice sites, promoter elements. Medium context (1 to 10 kb) spans complete genes with proximal regulatory regions. Long context (10 to 200 kb) represents enhancer-promoter interactions and TAD-scale organization. Ultra-long context (over 200 kb) enables chromosomal domain modeling and complex structural variant interpretation. The effective use of long context requires appropriate tokenization and positional encoding (@sec-ch05-representations).


### Tokenization {#sec-ch10-tokenization}

The representation of nucleotides as model inputs affects both computational efficiency and biological resolution. Character-level tokenization maintains single-base resolution but imposes longest sequence lengths. *K*-mer tokenization reduces length by a factor approaching *k*, with vocabulary reaching 4,096 for 6-mers. Learned tokenization (BPE-style) discovers schemes from data, potentially allocating vocabulary more efficiently. The choice should align with both computational constraints and biological resolution requirements. Detailed discussion of tokenization strategies appears in @sec-ch05-representations.

::: {#fig-design-dimensions}
![**FIGURE PLACEHOLDER**](https://placehold.co/300x200?text=FIGURE%20PLACEHOLDER)

[High] Multi-axis comparison (radar/spider plot or parallel coordinates) showing how different models make different design choices. Axes: (1) Context Length: 512bp to 1Mb; (2) Parameter Count: 10M to 15B; (3) Species Coverage: Human-only to Pan-genomic; (4) Architecture Type: CNN to Transformer to Hybrid to SSM; (5) Tokenization: Character to *k*-mer to BPE to Codon-aware; (6) Pretraining Objective: MLM to Autoregressive to Multi-task supervised. Models plotted: *DNABERT-2*, *HyenaDNA*, *Evo 2*, *Enformer*, *Nucleotide Transformer*.
:::


## Build Versus Use Decisions {#sec-ch10-build-vs-use}

The availability of pretrained foundation models creates strategic choices about when to use existing models, when to adapt them, and when to train from scratch.


### When to Use Existing Models {#sec-ch10-use-existing}

Existing foundation models provide immediate utility when the target application aligns with model capabilities, labeled data is limited, and computational resources are constrained.

For tasks where general sequence representations suffice, frozen foundation model embeddings with simple downstream classifiers often perform competitively with fine-tuned alternatives. This approach requires minimal compute (single forward passes), no gradient computation through large models, and modest labeled data (hundreds to thousands of examples). Applications include sequence classification, clustering, and similarity search.

Some foundation models support zero-shot variant effect prediction through likelihood ratio scoring. This requires no task-specific training and produces calibrated scores for novel variants immediately. Zero-shot approaches work well when the pretraining objective aligns with the target task and when fine-tuning data is unavailable or unreliable.

Foundation model APIs also enable rapid prototyping, allowing quick assessment of whether a modeling approach is viable before committing resources to custom development. Testing variant effect prediction with *ESM-1v* takes hours rather than the weeks required to train a custom model.


### When to Adapt Existing Models {#sec-ch10-adapt-existing}

Adaptation through fine-tuning or lightweight methods (LoRA, adapters, prefix tuning) makes sense when downstream tasks require specialized behavior beyond what frozen embeddings provide, sufficient labeled data exists (typically thousands to tens of thousands of examples), and the target domain falls within the pretraining distribution.

Parameter-efficient methods like LoRA update a small fraction of model parameters (often under 1%) while keeping the foundation model frozen. This preserves general knowledge while allowing task-specific adaptation. Compute requirements are modest: a few GPU-hours for most genomic tasks. The approach works well when the foundation model's representations are largely appropriate but need refinement for specific applications. Details on parameter-efficient adaptation appear in @sec-ch09-transfer.

Updating all parameters typically achieves the best single-task performance but requires more data (tens of thousands of examples), more compute (GPU-days to weeks), and careful regularization to prevent **overfitting**. Full fine-tuning makes sense for high-stakes applications where maximum accuracy justifies the investment.


### When to Train from Scratch {#sec-ch10-train-scratch}

Building custom foundation models requires substantial justification given the resources involved.

Novel domains present the clearest case for custom pretraining. When target sequences differ fundamentally from existing model pretraining data (novel species, synthetic sequences, non-standard nucleotides), existing models may provide poor transfer. Applications requiring architectural features absent from existing models (specific attention patterns, custom tokenization, multi-modal inputs) similarly demand building from scratch.

Organizations with unique large-scale datasets (clinical biobanks, pharmaceutical screening data) may achieve better performance through custom pretraining than public models allow, though the data advantage must be substantial to justify training costs. Applications requiring larger models or longer contexts than available options face similar calculus.


### Cost-Benefit Analysis {#sec-ch10-cost-benefit}

The decision framework involves comparing expected performance against resource requirements.

Training a foundation model from scratch requires 10^20 to 10^22 FLOPs, translating to thousands of GPU-hours and tens of thousands of dollars at current cloud prices. Fine-tuning requires 10^16 to 10^18 FLOPs, often achievable in hours on single GPUs. Inference with frozen embeddings requires only forward passes.

Foundation model pretraining requires billions of tokens. Fine-tuning requires thousands to tens of thousands of labeled examples. Zero-shot and embedding approaches require only evaluation data.

For well-studied tasks with abundant labeled data, fine-tuned models typically outperform frozen embeddings by 5 to 15% on standard metrics. Zero-shot approaches often achieve 70 to 90% of fine-tuned performance. Custom foundation models rarely outperform existing options by large margins unless the application involves genuinely novel domains. *[Citation Needed]*

::: {#fig-build-vs-use}
![**FIGURE PLACEHOLDER**](https://placehold.co/300x200?text=FIGURE%20PLACEHOLDER)

[High] Decision flowchart with cost-benefit annotations. Entry Point: "New genomic prediction task." Decision nodes leading to terminal recommendations: USE (Frozen embeddings + simple classifier, Hours/$10, 70-90% of fine-tuned); ADAPT (LoRA/adapter fine-tuning, Days/$100-1000, 95% of full fine-tuning); BUILD (Custom pretraining, Months/$100K+, potentially best for domain). Annotations: "Most applications land here" pointing to USE/ADAPT paths; "Rare but sometimes necessary" pointing to BUILD.
:::

Time costs often dominate: using existing models takes hours to days, fine-tuning takes days to weeks, training from scratch takes weeks to months. For time-sensitive applications, using existing models often dominates even if custom training would eventually yield better results.

The practical recommendation for most applications: start with frozen embeddings from the most appropriate existing foundation model. If performance is insufficient, try parameter-efficient fine-tuning. Train from scratch only if adaptation fails and the application justifies the investment.


## Evaluation Principles {#sec-ch10-evaluation}

Foundation models resist evaluation on single tasks. Their value lies in transfer across many applications, making comprehensive evaluation substantially more complex than benchmarking task-specific models.


### Multi-Task Assessment {#sec-ch10-multi-task}

A genomic foundation model should be evaluated across families of related tasks rather than isolated benchmarks. For DNA language models, this includes sequence classification tasks, variant effect prediction across multiple variant types, motif discovery, and cross-species transfer. For sequence-to-function models, evaluation should span prediction of held-out assays, transfer to novel cell types, and consistency with experimental measurements.

The diversity of evaluation tasks complicates comparison across models. A model excelling at promoter classification may underperform on eQTL fine-mapping. Direct comparisons require controlling for differences in training data, model scale, and evaluation protocols. Standardized benchmark suites are examined in @sec-ch20-benchmarks.


### Transfer Versus Pretraining Performance {#sec-ch10-transfer-eval}

Foundation models are intended for transfer, making pretraining loss only moderately predictive of downstream utility. A model with slightly worse masked language modeling loss may produce better embeddings if its training objective better aligns with useful representations. Evaluation should explicitly test transfer through zero-shot performance, few-shot learning, cross-domain transfer, and robustness to distribution shift.

Detailed discussion of benchmark suites, evaluation protocols, and methodological best practices appears in @sec-ch20-benchmarks and @sec-ch21-eval.


## Foundation Model Ecosystem {#sec-ch10-ecosystem}

Genomic foundation models exist within a broader ecosystem of infrastructure, community resources, and shared practices.


### Model Distribution {#sec-ch10-distribution}

Most models are distributed through centralized repositories. Hugging Face hosts many DNA and protein language models with documented APIs. GitHub repositories accompany publications with weights, code, and examples. Standardized formats reduce friction in adoption, enabling rapid benchmarking and experimentation.


### Documentation Requirements {#sec-ch10-documentation}

Responsible distribution requires comprehensive documentation: training data provenance, preprocessing procedures, architecture details, hyperparameters, evaluation protocols, and known limitations. Data provenance is particularly important given population-specific biases and use restrictions in genomic datasets (@sec-ch22-confounding).


### Industry and Academic Contributions {#sec-ch10-contributions}

Both academic and industry groups develop genomic foundation models. Academic models emphasize reproducibility and open access. Industry models may offer superior performance through proprietary data or compute but with limited transparency. Notable industry contributions include NVIDIA's BioNeMo platform and Microsoft's Azure genomics integration. Users should review license terms before clinical or commercial deployment.


## Open Questions {#sec-ch10-open-questions}

Despite rapid progress, fundamental challenges remain unsolved, and the field's trajectory remains uncertain.

Whether genomic foundation models converge toward unified architectures or maintain specialized families is unclear. The diversity of genomic scales, resolution requirements, and functional contexts may preclude the convergence seen in NLP, where transformers now dominate across most tasks.

Existing models learn correlations without distinguishing causal from spurious relationships. Integrating causal structure could improve robustness and enable counterfactual reasoning, but current architectures provide no principled mechanism for causal inference (@sec-ch22-confounding).

Models trained on reference genomes and common variants may not calibrate well for ultra-rare or *de novo* variants, precisely the variants most likely to be clinically actionable (@sec-ch26-rare-disease). Improved integration of structural and evolutionary constraints could strengthen rare variant interpretation.

Translation to clinical use requires robust cross-population performance, calibrated uncertainty (@sec-ch23-uncertainty), interpretability for clinicians (@sec-ch24-interpretability), prospective validation, and regulatory approval. These requirements extend well beyond benchmark performance, and the path from research model to clinical deployment remains poorly charted.


## Convergence Without Consolidation {#sec-ch10-convergence}

Foundation models for genomics divide into families serving different needs. DNA language models learn general sequence representations from self-supervised pretraining, capturing evolutionary constraints and regulatory patterns without explicit functional labels (@sec-ch11-dna-lm). Sequence-to-function models predict molecular phenotypes from sequence, providing quantitative outputs (expression levels, chromatin states, splice probabilities) that DNA language models alone cannot produce (@sec-ch13-regulatory). Variant effect models integrate sequence representations with evolutionary information to score the functional impact of genetic variants (@sec-ch14-vep-fm). Multi-omic models combine sequence with additional data modalities to capture regulatory relationships that sequence alone cannot resolve (@sec-ch19-multi-omics). No single family dominates; effective genomic AI requires matching model capabilities to application requirements.

Scale introduces both opportunities and constraints. Scaling laws describe predictable relationships between parameters, data, compute, and performance, enabling principled resource allocation. Some capabilities appear only at sufficient scale, creating thresholds that cannot be crossed through fine-tuning alone. The practical implication is that certain applications require institutional-scale investment, while others can leverage existing pretrained models with modest adaptation. The build-versus-use framework guides this decision: use existing models when they suffice, adapt through fine-tuning or feature extraction when needed, train from scratch only when unique data or requirements justify the investment.

This framework instantiates across specific domains. DNA language models (@sec-ch11-dna-lm) and protein language models (@sec-ch12-protein-lm) exemplify self-supervised pretraining on biological sequence. Regulatory models (@sec-ch13-regulatory) demonstrate sequence-to-function prediction at long-range scales. Variant effect prediction (@sec-ch14-vep-fm) integrates multiple model families for clinical interpretation. Throughout, these principles guide model selection: what does this application require, which model family provides it, and what scale is necessary to achieve it?