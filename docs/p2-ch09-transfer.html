<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>9&nbsp; Transfer Learning and Adaptation – Genomic Foundation Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./p3--architectures.html" rel="next">
<link href="./p2-ch08-pretraining.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-b758ccaa5987ceb1b75504551e579abf.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-a1553387a0f784068632030e9fbb8a3c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-d1e9b63c6b6094879b9f94a7628e3370.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/bootstrap/bootstrap-a1553387a0f784068632030e9fbb8a3c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./p2--principles.html">Part II: Core Principles</a></li><li class="breadcrumb-item"><a href="./p2-ch09-transfer.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Transfer Learning and Adaptation</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Genomic Foundation Models</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./p1--foundations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part I: Foundations</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p1-ch01-ngs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sequencing: From Reads to Variants</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p1-ch02-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Genomic Data Landscape</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p1-ch03-gwas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">GWAS and Polygenic Scores</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p1-ch04-vep-classical.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Classical Variant Effect Prediction</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./p2--principles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part II: Core Principles</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p2-ch05-representations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Sequence Representation and Tokenization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p2-ch06-cnn.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Convolutional Models for Genomic Sequence</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p2-ch07-attention.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Attention and Transformers</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p2-ch08-pretraining.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Pretraining Objectives and Strategies</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p2-ch09-transfer.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Transfer Learning and Adaptation</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./p3--architectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part III: Deep Learning Architectures</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p3-ch10-fm-principles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">The Foundation Model Paradigm</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p3-ch11-dna-lm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">DNA Language Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p3-ch12-protein-lm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Protein Language Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p3-ch13-regulatory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Long-Context Regulatory Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p3-ch14-vep-fm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Variant Effect Prediction with Foundation Models</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./p4--multi-scale.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part IV: Multi-Scale Modeling</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p4-ch15-rna.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">RNA Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p4-ch16-single-cell.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Single-Cell and Epigenomic Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p4-ch17-3d-genome.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">3D Genome and Spatial Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p4-ch18-networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Gap Analysis: Chapter 18 Networks and Graph-Based Reasoning</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p4-ch19-multi-omics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Multi-Omics Integration</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./p5--eval-interp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part V: Evaluation and Reliability</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p5-ch20-benchmarks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Benchmarks for Genomic AI</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p5-ch21-eval.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Evaluation Methodology</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p5-ch22-confounding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Confounders in Model Training</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p5-ch23-uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">Uncertainty Quantification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p5-ch24-interpretability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Interpretability and Mechanism</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./p6--translation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Part VI — Translation and Application</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p6-ch25-clinical-risk.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">Clinical Risk Prediction</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p6-ch26-rare-disease.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">Rare Disease and Variant Interpretation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p6-ch27-drug-discovery.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">Drug Discovery and Target Identification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p6-ch28-design.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">Sequence Design and Engineering</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./p6-ch29-future.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Regulatory, Ethical, and Future Considerations</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./app-a-dl.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Deep Learning Primer</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./app-b-compute.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Model Deployment</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./app-c-data-curation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Training Data Curation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./app-d-models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Referenced Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./app-e-resources.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Additional Resources</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./app-f-glossary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Glossary</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-promise-of-universal-representations" id="toc-the-promise-of-universal-representations" class="nav-link active" data-scroll-target="#the-promise-of-universal-representations"><span class="header-section-number">9.1</span> The Promise of Universal Representations</a></li>
  <li><a href="#source-and-target-domains" id="toc-source-and-target-domains" class="nav-link" data-scroll-target="#source-and-target-domains"><span class="header-section-number">9.2</span> Source and Target Domains</a></li>
  <li><a href="#feature-extraction-with-frozen-backbones" id="toc-feature-extraction-with-frozen-backbones" class="nav-link" data-scroll-target="#feature-extraction-with-frozen-backbones"><span class="header-section-number">9.3</span> Feature Extraction with Frozen Backbones</a></li>
  <li><a href="#parameter-efficient-fine-tuning" id="toc-parameter-efficient-fine-tuning" class="nav-link" data-scroll-target="#parameter-efficient-fine-tuning"><span class="header-section-number">9.4</span> Parameter-Efficient Fine-Tuning</a></li>
  <li><a href="#full-fine-tuning" id="toc-full-fine-tuning" class="nav-link" data-scroll-target="#full-fine-tuning"><span class="header-section-number">9.5</span> Full Fine-Tuning</a></li>
  <li><a href="#probing-representations" id="toc-probing-representations" class="nav-link" data-scroll-target="#probing-representations"><span class="header-section-number">9.6</span> Probing Representations</a></li>
  <li><a href="#choosing-an-adaptation-strategy" id="toc-choosing-an-adaptation-strategy" class="nav-link" data-scroll-target="#choosing-an-adaptation-strategy"><span class="header-section-number">9.7</span> Choosing an Adaptation Strategy</a></li>
  <li><a href="#domain-shift-and-cross-context-transfer" id="toc-domain-shift-and-cross-context-transfer" class="nav-link" data-scroll-target="#domain-shift-and-cross-context-transfer"><span class="header-section-number">9.8</span> Domain Shift and Cross-Context Transfer</a></li>
  <li><a href="#few-shot-and-zero-shot-learning" id="toc-few-shot-and-zero-shot-learning" class="nav-link" data-scroll-target="#few-shot-and-zero-shot-learning"><span class="header-section-number">9.9</span> Few-Shot and Zero-Shot Learning</a></li>
  <li><a href="#when-transfer-fails" id="toc-when-transfer-fails" class="nav-link" data-scroll-target="#when-transfer-fails"><span class="header-section-number">9.10</span> When Transfer Fails</a></li>
  <li><a href="#case-studies-in-transfer-learning" id="toc-case-studies-in-transfer-learning" class="nav-link" data-scroll-target="#case-studies-in-transfer-learning"><span class="header-section-number">9.11</span> Case Studies in Transfer Learning</a></li>
  <li><a href="#validation-and-common-pitfalls" id="toc-validation-and-common-pitfalls" class="nav-link" data-scroll-target="#validation-and-common-pitfalls"><span class="header-section-number">9.12</span> Validation and Common Pitfalls</a></li>
  <li><a href="#emerging-directions" id="toc-emerging-directions" class="nav-link" data-scroll-target="#emerging-directions"><span class="header-section-number">9.13</span> Emerging Directions</a></li>
  <li><a href="#practical-guidelines" id="toc-practical-guidelines" class="nav-link" data-scroll-target="#practical-guidelines"><span class="header-section-number">9.14</span> Practical Guidelines</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./p2--principles.html">Part II: Core Principles</a></li><li class="breadcrumb-item"><a href="./p2-ch09-transfer.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Transfer Learning and Adaptation</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-transfer" class="quarto-section-identifier"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Transfer Learning and Adaptation</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="the-promise-of-universal-representations" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="the-promise-of-universal-representations"><span class="header-section-number">9.1</span> The Promise of Universal Representations</h2>
<p>Train once, deploy everywhere. This vision drives the foundation model paradigm: invest heavily in pretraining on massive unlabeled data, then adapt the resulting model cheaply to any downstream task. The appeal is obvious. Rather than training separate models for splice site prediction, variant effect scoring, and regulatory element identification, a single pretrained model provides a universal starting point that can be fine-tuned with minimal labeled data. The representations learned during pretraining capture general sequence patterns (motifs, compositional regularities, long-range dependencies) that transfer across tasks, reducing both the data and compute required for each new application.</p>
<p>The reality proves more nuanced. Transfer learning succeeds spectacularly in some settings: protein language models predict variant effects with near-zero task-specific training, achieving competitive performance through log-likelihood ratios alone. DNA foundation models enable chromatin accessibility prediction from a few hundred labeled examples. Yet transfer also fails in subtle and frustrating ways. Models trained on human sequences struggle with other species. Representations optimized for coding regions miss noncoding regulatory logic. Tasks that seem conceptually similar turn out to require incompatible features. <strong>The central challenge of transfer learning is not whether to adapt pretrained models, but knowing when adaptation will help and choosing strategies that maximize benefit while minimizing risk.</strong></p>
<p>The adaptation strategies examined in this chapter span a spectrum from minimal intervention (frozen features with a linear probe) to aggressive modification (full fine-tuning of all parameters). Each point on this spectrum trades off preservation of pretrained knowledge against flexibility for task-specific learning. Frozen approaches guarantee that pretrained representations remain intact but cannot escape their limitations. Fine-tuning enables task-specific optimization but risks overwriting useful general knowledge. Parameter-efficient methods attempt to navigate this tension, enabling targeted adaptation while protecting the bulk of pretrained weights. Understanding when each strategy is appropriate, and developing intuition for diagnosing transfer failures, separates effective practitioners from those who apply foundation models as black boxes.</p>
</section>
<section id="source-and-target-domains" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="source-and-target-domains"><span class="header-section-number">9.2</span> Source and Target Domains</h2>
<p>Transfer learning operates across two domains: the source domain where pretraining occurs and the target domain where the model will be deployed. Understanding what properties of each domain determine transfer success provides the conceptual foundation for choosing adaptation strategies.</p>
<p>The source domain in genomics typically consists of abundant unlabeled sequence data. For DNA models, this might span the human reference genome, pan-genomes from multiple species, or metagenomic collections from environmental samples. For protein models, UniRef and similar databases provide billions of sequences sampling the diversity of evolutionary history. Pretraining objectives like masked language modeling encourage models to learn regularities that help predict held-out tokens: local motifs, compositional patterns, long-range dependencies, and the statistical signatures that distinguish functional from random sequence. These learned regularities form the representations that transfer to downstream tasks.</p>
<p>The target domain differs fundamentally. Rather than abundant unlabeled data, the target domain offers sparse labeled examples of a specific task. A few thousand enhancer sequences with luciferase activity measurements. Several hundred variants with clinical pathogenicity classifications. Chromatin accessibility profiles across a handful of cell types. The target distribution may look nothing like the pretraining data. Pathogenic variants are rare outliers, not typical genomic sequence. Tissue-specific enhancers exhibit patterns that genome-wide pretraining may never emphasize. The gap between source and target distributions creates the core transfer learning challenge.</p>
<p>Several factors determine whether this gap can be bridged. Task relatedness matters profoundly. If the target task requires sequence patterns similar to those the model encountered during pretraining, the pretrained representations will prove useful. If the target task depends on patterns the pretraining objective ignored or actively suppressed, transfer may provide little benefit. Target data quantity constrains which adaptation strategies are feasible. With thousands of labeled examples, aggressive fine-tuning can reshape representations toward task requirements. With dozens of examples, only the lightest-touch approaches avoid overfitting. Model architecture and scale influence adaptation flexibility: larger models with more expressive internal representations can potentially adapt to more diverse tasks, but also risk memorizing small target datasets.</p>
<p>Not all transfer helps. Positive transfer accelerates learning or improves final performance beyond what training from scratch achieves. Negative transfer occurs when pretraining actively hurts performance, either because learned features conflict with task requirements or because the pretrained initialization creates optimization difficulties. Neutral transfer describes situations where pretraining neither helps nor hurts, often when target data is sufficient to learn effectively from scratch or when source and target domains share too little structure for meaningful knowledge sharing. Distinguishing these outcomes requires careful empirical validation, not assumptions about how transfer “should” work.</p>
</section>
<section id="feature-extraction-with-frozen-backbones" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="feature-extraction-with-frozen-backbones"><span class="header-section-number">9.3</span> Feature Extraction with Frozen Backbones</h2>
<p>The simplest adaptation strategy treats the pretrained model as a fixed feature extractor. All backbone parameters remain frozen; only a lightweight classifier trained on top of the extracted representations learns from labeled data. This approach eliminates the risk of catastrophic forgetting (where fine-tuning overwrites useful pretrained knowledge) and requires minimal computation since gradients need not flow through the entire model.</p>
<p>Implementation is straightforward. Pass input sequences through the frozen backbone to obtain embeddings, typically from the final layer or from a designated [CLS] token that aggregates sequence information. These embeddings serve as fixed feature vectors capturing the model’s learned understanding of sequence patterns. Train a supervised classifier (logistic regression, linear layer, or shallow neural network) to map embeddings to task labels. The backbone parameters never change.</p>
<p>Linear probing represents the minimal variant. A single linear layer maps embeddings directly to predictions, introducing only <span class="math inline">\(d \times c\)</span> parameters where <span class="math inline">\(d\)</span> is the embedding dimension and <span class="math inline">\(c\)</span> is the number of output classes. This approach trains in minutes and resists overfitting even with very limited labeled data. DNABERT embeddings paired with linear probes achieve competitive chromatin accessibility prediction from a few hundred positive and negative examples, matching CNN baselines that require far more labeled data. The success reflects alignment between the pretraining objective (predicting masked k-mers from context) and the target task (distinguishing sequences based on local motif patterns).</p>
<p>Shallow multilayer perceptrons extend linear probing by adding one or two hidden layers between embeddings and predictions. The additional nonlinearity enables more complex decision boundaries while maintaining computational efficiency and overfitting resistance. With a few thousand labeled examples, shallow MLPs on HyenaDNA embeddings improve splice site prediction over linear probes, capturing interactions between features that linear models cannot represent.</p>
<p>The advantages of frozen feature extraction are clear. Computational cost is minimal. Catastrophic forgetting is impossible since pretrained parameters never change. Training completes quickly, enabling rapid experimentation across tasks. The approach works reliably even with very small labeled datasets. But these advantages come with a fundamental limitation: the backbone cannot adapt to task-specific patterns. Performance is capped by how well pretrained representations align with target task requirements. If the pretraining objective emphasized patterns irrelevant to the downstream task, or if the target task requires features the pretraining objective actively discouraged, frozen features will underperform models trained from scratch regardless of how sophisticated the classifier head becomes.</p>
</section>
<section id="parameter-efficient-fine-tuning" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="parameter-efficient-fine-tuning"><span class="header-section-number">9.4</span> Parameter-Efficient Fine-Tuning</h2>
<p>Parameter-efficient fine-tuning (PEFT) methods navigate the tension between frozen and full fine-tuning by updating a small subset of parameters while keeping the majority frozen. The model can adapt to task-specific patterns without the computational expense or overfitting risk of modifying all weights. Several PEFT techniques have emerged, with Low-Rank Adaptation (LoRA) proving particularly prominent in genomic applications.</p>
<p>LoRA modifies weight matrices by adding low-rank decompositions. Rather than updating a large weight matrix <span class="math inline">\(W\)</span> directly, LoRA introduces two smaller matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> whose product approximates the desired weight change: <span class="math inline">\(W' = W + BA\)</span>. During fine-tuning, <span class="math inline">\(W\)</span> remains frozen while only <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> receive gradient updates. The rank of these matrices (typically 8 to 64 for genomic models) controls the expressiveness of adaptation. Lower ranks introduce fewer parameters and stronger regularization; higher ranks enable more flexible task-specific modification at greater overfitting risk.</p>
<p>The memory and compute savings can be substantial. A transformer with hundreds of millions of parameters might require updating only a few million LoRA parameters, reducing memory requirements by 10 to 100 times compared to full fine-tuning. This efficiency enables training on consumer hardware for models that would otherwise require specialized infrastructure. LoRA adapters on Nucleotide Transformer have enabled tissue-specific expression prediction, where separate low-rank matrices capture tissue-specific regulatory patterns while the pretrained backbone encodes general sequence understanding.</p>
<p>Adapter layers take a different architectural approach. Rather than modifying existing weight matrices, adapters insert small bottleneck modules between transformer layers. Each adapter consists of a down-projection reducing dimensionality, a nonlinear activation, and an up-projection restoring the original dimension. The original transformer parameters remain frozen; only adapter parameters are updated. Different adapters can be trained for different tasks, enabling multi-task deployment from a single shared backbone. Enformer with tissue-specific adapters predicts chromatin states across cell types, with each adapter learning tissue-specific transformations of shared regulatory representations.</p>
<p>Prefix tuning prepends learnable embeddings to the input, effectively providing task-specific context that conditions model behavior. While less common in genomics due to the absence of natural “prompt” structure in biological sequence, prefix tuning has found limited application where task context can be encoded as additional input tokens. Other PEFT methods include BitFit (tuning only bias terms), prompt tuning (learning soft prompts), and compacter-style approaches combining low-rank decomposition with parameter sharing. These remain less explored in genomic contexts but may offer advantages for specific applications.</p>
<p>PEFT methods suit intermediate data regimes (thousands to tens of thousands of examples) where frozen features underperform but full fine-tuning risks overfitting. They enable managing multiple related tasks efficiently, training separate lightweight adapters rather than separate full models. The computational savings make experimentation feasible on modest hardware, accelerating development cycles.</p>
</section>
<section id="full-fine-tuning" class="level2" data-number="9.5">
<h2 data-number="9.5" class="anchored" data-anchor-id="full-fine-tuning"><span class="header-section-number">9.5</span> Full Fine-Tuning</h2>
<p>Full fine-tuning updates all model parameters during adaptation, offering maximum flexibility to reshape representations for task-specific requirements. When target datasets are large enough and the target task diverges sufficiently from pretraining, full fine-tuning extracts more value from pretrained models than constrained approaches.</p>
<p>Implementation requires careful attention to optimization details. Learning rates must be substantially lower than during pretraining (often 10 to 100 times smaller) to avoid catastrophically disrupting learned representations in early training steps. Gradual unfreezing, where top layers are updated first and deeper layers are progressively brought into training, helps preserve low-level features while allowing high-level task-specific adjustment. Regularization through weight decay, dropout, and early stopping on validation data prevents overfitting to the target dataset.</p>
<p>Full fine-tuning is appropriate when labeled datasets are large (tens of thousands of examples or more), when the target task differs substantially from pretraining such that frozen or lightly adapted representations prove insufficient, or when performance requirements justify the computational investment. Enformer fine-tuned on new chromatin assays requires updating most parameters to capture assay-specific signal patterns distinct from original training conditions. The expense is justified when the adapted model will be deployed at scale or when the task is central to a research program.</p>
<p>The risks are real. Catastrophic forgetting occurs when fine-tuning overwrites general knowledge useful for related tasks or out-of-distribution inputs. A model fine-tuned aggressively on one tissue type may lose performance on others it previously handled well. Overfitting afflicts small target datasets, where the model memorizes training examples rather than learning generalizable patterns. Computational expense can be prohibitive for large models. These considerations make full fine-tuning a high-reward, high-risk strategy requiring careful validation that the investment yields genuine improvement over simpler approaches.</p>
<p>Best practices emphasize starting conservatively. Begin with frozen features to establish whether transfer provides any benefit. If frozen features improve over training from scratch, try PEFT methods before committing to full fine-tuning. Always compare full fine-tuning against simpler baselines; if the performance gap is small, the additional cost may not be justified.</p>
</section>
<section id="probing-representations" class="level2" data-number="9.6">
<h2 data-number="9.6" class="anchored" data-anchor-id="probing-representations"><span class="header-section-number">9.6</span> Probing Representations</h2>
<p>Probing classifiers diagnose what information pretrained representations encode, guiding adaptation strategy by revealing alignment (or misalignment) between learned features and task requirements. Rather than immediately training for the target task, probing systematically interrogates representations to understand their structure.</p>
<p>The approach is simple: train lightweight classifiers to predict properties of interest from frozen embeddings, then examine how well different properties can be decoded. If chromatin accessibility can be predicted accurately from a linear probe, the representations already encode accessibility-relevant features and frozen feature extraction will likely succeed. If transcription factor binding requires a deep nonlinear classifier, the relevant information may be present but not linearly separable, suggesting that PEFT or fine-tuning might reorganize representations for easier extraction. If a property cannot be predicted even with flexible classifiers, the representations may lack the necessary information entirely.</p>
<p>Systematic probing reveals what models learn during pretraining. DNA language models encode local motif information recoverable by simple linear probes but show weaker encoding of long-range dependencies that require multi-layer networks to extract. Protein language models learn secondary structure so thoroughly that linear probes achieve near state-of-the-art prediction accuracy, while tertiary contact information requires nonlinear decoding. These probing results explain why certain transfer tasks succeed readily (they rely on well-encoded features) while others prove difficult (they require information the model encodes weakly or not at all).</p>
<p>Probing guides adaptation decisions. If the target task requires features that probing reveals as well-encoded, frozen feature extraction or minimal adaptation should suffice. If required features are present but deeply buried (requiring nonlinear probes to extract), PEFT methods may help by learning transformations that surface the relevant information. If probing suggests required features are absent or very weakly encoded, practitioners face a choice: either full fine-tuning to reshape representations (if target data is sufficient) or trying a different pretrained model whose pretraining objective better aligns with task requirements.</p>
<p>Layer-wise probing reveals how information flows through the model. Early layers often encode local compositional features (k-mer frequencies, simple motifs) while later layers capture more abstract patterns (long-range dependencies, functional signatures). Tasks depending on local features may benefit from representations extracted from early or middle layers rather than the final layer, which may have abstracted away relevant details. Layer selection becomes another hyperparameter to optimize when adapting pretrained models.</p>
</section>
<section id="choosing-an-adaptation-strategy" class="level2" data-number="9.7">
<h2 data-number="9.7" class="anchored" data-anchor-id="choosing-an-adaptation-strategy"><span class="header-section-number">9.7</span> Choosing an Adaptation Strategy</h2>
<p>Selecting the appropriate adaptation strategy requires balancing three considerations: available labeled data, similarity between pretraining and target tasks, and computational budget. While no rigid rules cover all scenarios, several heuristics guide practical decisions.</p>
<p>Data quantity provides the primary decision axis. With fewer than 1,000 labeled examples, linear probing or shallow classifiers on frozen embeddings is often the only viable approach. More complex adaptation risks overfitting; the limited signal cannot support updating many parameters. With 1,000 to 10,000 examples, PEFT methods offer good tradeoffs between expressiveness and regularization. With more than 10,000 examples, full fine-tuning becomes feasible and may be necessary if the target task diverges substantially from pretraining.</p>
<p>Task similarity to pretraining provides the second axis. When target tasks closely resemble pretraining patterns (predicting transcription factor binding after sequence pretraining involves similar local motif recognition), frozen feature extraction often suffices. The pretrained representations already capture relevant patterns; a simple classifier separates positive from negative examples. For moderately different tasks, PEFT methods enable selective adaptation. For tasks fundamentally different from pretraining (where required features were not emphasized or were actively suppressed during pretraining), full fine-tuning may be necessary to reshape representations.</p>
<p>Computational budget imposes practical constraints. With minimal resources, only linear probing is feasible. With moderate resources, LoRA achieves much of fine-tuning’s benefit at a fraction of the cost. With generous resources, full fine-tuning becomes an option, though comparing against simpler baselines remains essential to verify the investment is justified.</p>
<p>Empirical validation trumps heuristics. No rule perfectly predicts which strategy will succeed. Always compare multiple approaches. Validate on held-out data matching the intended deployment distribution. Monitor for overfitting versus underfitting and adjust strategy accordingly. The goal is developing intuition for which strategies merit trying, not blindly following rules.</p>
</section>
<section id="domain-shift-and-cross-context-transfer" class="level2" data-number="9.8">
<h2 data-number="9.8" class="anchored" data-anchor-id="domain-shift-and-cross-context-transfer"><span class="header-section-number">9.8</span> Domain Shift and Cross-Context Transfer</h2>
<p>Transfer learning assumes that knowledge from the source domain applies to the target domain. When this assumption breaks, performance degrades in ways that may not be obvious from standard validation metrics. Three types of domain shift commonly afflict genomic transfer: cross-species, cross-tissue, and cross-assay transfer.</p>
<p>Cross-species transfer applies models trained on one organism to another. The challenge is that evolutionary divergence introduces sequence differences affecting regulatory patterns, motif syntax, and functional constraints. Strategies for cross-species success include pretraining on multi-species data to learn conservation patterns, fine-tuning with species-specific adapters, and focusing on highly conserved features that transfer more readily. Human-to-mouse regulatory prediction faces both sequence divergence and lineage-specific regulatory innovations; core promoter elements transfer better than species-specific enhancers. Transfer across greater phylogenetic distances becomes progressively more difficult.</p>
<p>Cross-tissue transfer addresses tissue-specific regulatory programs. Gene expression and chromatin accessibility vary dramatically across tissues, with thousands of tissue-specific enhancers and repressors. Models trained predominantly on one tissue may miss regulatory logic specific to others. Effective strategies include shared backbones with tissue-specific prediction heads, tissue-conditional models taking tissue identity as input, and meta-learning approaches training across many tissues to extract general principles. Broadly expressed housekeeping genes transfer more readily than tissue-restricted genes.</p>
<p>Cross-assay transfer handles different molecular readouts of related biology. ChIP-seq and ATAC-seq both measure chromatin state but with different biochemistry and signal characteristics. Bulk and single-cell RNA-seq quantify expression at vastly different scales. Successful cross-assay transfer requires understanding the mechanistic relationships between assays and either multi-task pretraining across assays or explicit modeling of assay-specific biases.</p>
<p>Detecting domain shift before deployment prevents silent failures. Statistical tests comparing source and target distributions flag potential problems. Embedding visualizations reveal whether target examples fall within the source distribution or in unfamiliar regions of representation space. Monitoring performance on “canary” examples (known easy cases that should always be predicted correctly) provides early warning of severe shift.</p>
</section>
<section id="few-shot-and-zero-shot-learning" class="level2" data-number="9.9">
<h2 data-number="9.9" class="anchored" data-anchor-id="few-shot-and-zero-shot-learning"><span class="header-section-number">9.9</span> Few-Shot and Zero-Shot Learning</h2>
<p>Few-shot learning addresses scenarios with extremely scarce labels: 10 to 100 examples per class rather than thousands. This regime characterizes many genomic applications. Rare variant classes in ClinVar have few examples. Novel cell types in single-cell studies lack extensive annotation. Newly characterized functional elements have limited experimental validation. Standard adaptation approaches overfit catastrophically with so few examples.</p>
<p>Meta-learning trains models explicitly for rapid adaptation. Model-Agnostic Meta-Learning (MAML) finds parameter initializations that can be fine-tuned effectively from minimal data. The model learns across many few-shot tasks during meta-training, optimizing for fast adaptation rather than performance on any single task. At deployment, a few gradient steps on new labeled examples produce a task-specific model. Prototypical networks learn to classify based on distance to class prototypes in embedding space, enabling classification from a handful of examples per class. These approaches remain underexplored in genomics but offer promise for the many settings where labels are genuinely scarce.</p>
<p>Zero-shot transfer makes predictions without any task-specific adaptation. The pretrained model produces outputs that can be interpreted as task predictions without further training. For protein variant effect prediction, ESM log-likelihood ratios score variants by how much they reduce the model’s probability of the observed sequence. Variants disrupting the model’s learned expectations for natural proteins are flagged as potentially deleterious. This approach proves competitive with supervised methods because evolutionary constraint (captured by pretraining on natural sequences) correlates with functional importance.</p>
<p>Zero-shot methods require strong alignment between pretraining objectives and target tasks. In genomics, most practical applications still require at least some labeled data; few-shot learning represents a more realistic minimal-data regime than true zero-shot transfer.</p>
</section>
<section id="when-transfer-fails" class="level2" data-number="9.10">
<h2 data-number="9.10" class="anchored" data-anchor-id="when-transfer-fails"><span class="header-section-number">9.10</span> When Transfer Fails</h2>
<p>Transfer learning can fail spectacularly, and understanding failure modes prevents wasted effort on adaptation strategies that cannot succeed. Negative transfer occurs when pretraining actively hurts performance, producing models worse than those trained from scratch on target data alone.</p>
<p>Common failure modes include misaligned pretraining objectives that emphasize features irrelevant or counterproductive for the target task. A model pretrained to predict masked nucleotides in coding sequence may learn features specific to protein-coding regions that mislead when applied to noncoding regulatory elements. Pretraining on data from one species may encode species-specific patterns that create false expectations when transferred to another organism.</p>
<p>Diagnostic steps help identify whether transfer is helping or hurting. First, compare adapted model performance against a from-scratch baseline trained on the same target data. If the pretrained model does not outperform from-scratch training, transfer provides no benefit. Second, try simpler adaptation strategies before complex ones. If linear probing fails, full fine-tuning is unlikely to help unless the target dataset is large. Third, visualize embeddings from the pretrained model using dimensionality reduction. If target task examples are not well-separated in embedding space, the pretrained representations may not encode useful features for this task. Fourth, ablate pretraining entirely by comparing against randomly initialized models. This isolates whether pretrained weights provide value or whether architectural choices alone drive performance.</p>
<p>When diagnostics reveal fundamental mismatches, several solutions may help. Task-specific pretraining on data more closely aligned with the target task can bridge the gap. Pretraining specifically on regulatory regions for regulatory prediction tasks, rather than genome-wide pretraining, may produce more suitable representations. Hybrid approaches combining pretrained and from-scratch components allow selective use of transfer where it helps. Trying different foundation models may reveal better alternatives. And accepting that transfer does not help, proceeding with from-scratch training, remains a valid option when pretrained representations genuinely misalign with task requirements.</p>
</section>
<section id="case-studies-in-transfer-learning" class="level2" data-number="9.11">
<h2 data-number="9.11" class="anchored" data-anchor-id="case-studies-in-transfer-learning"><span class="header-section-number">9.11</span> Case Studies in Transfer Learning</h2>
<p>Examining concrete applications illustrates the principles developed throughout this chapter. Four case studies span different model architectures, adaptation strategies, and application domains.</p>
<p>DNABERT applied to chromatin accessibility prediction demonstrates successful feature extraction. The model was pretrained using masked language modeling on k-mer tokenized human genomic sequence. For ATAC-seq peak classification, a linear probe on [CLS] token embeddings achieved competitive performance with CNNs trained from scratch while requiring 10 times less labeled data. This success reflects strong alignment between pretraining (learning local sequence patterns) and the target task (identifying accessibility signals depending on motif composition). The lightweight adaptation was appropriate given limited labeled ATAC-seq data.</p>
<p>ESM for variant effect prediction illustrates zero-shot and minimal-supervision transfer. ESM was pretrained on UniRef protein sequences using masked language modeling. For ClinVar pathogenicity classification, zero-shot scoring based on how variants reduce sequence likelihood proved competitive with supervised methods. Adding a linear probe on ESM embeddings improved performance further. Pretraining captures the target objective implicitly: evolutionary constraint, which masked language modeling learns to predict, correlates with functional importance.</p>
<p>Enformer for cross-tissue gene expression shows benefits of full fine-tuning. Pretrained on thousands of chromatin and expression tracks, Enformer learned sequence-to-function mappings over long genomic contexts. Fine-tuning with tissue-specific prediction heads captured tissue-specific regulatory logic unavailable from frozen features, outperforming from-scratch models on individual tissues. The large scale of both pretraining and fine-tuning data justified computational expense.</p>
<p>HyenaDNA for regulatory element classification leverages long-range context. Pretrained on human genomic sequence with contexts up to one million base pairs, HyenaDNA embeddings capture distal regulatory relationships. LoRA adapters enabled efficient fine-tuning for enhancer and promoter classification, with long-range context improving accuracy on elements depending on distal interactions. This case demonstrates architecture-specific pretraining benefits: the long context that distinguishes HyenaDNA enables transfer to tasks where long-range dependencies matter.</p>
</section>
<section id="validation-and-common-pitfalls" class="level2" data-number="9.12">
<h2 data-number="9.12" class="anchored" data-anchor-id="validation-and-common-pitfalls"><span class="header-section-number">9.12</span> Validation and Common Pitfalls</h2>
<p>Proper validation distinguishes genuine transfer success from artifacts of evaluation design. Several failure modes pervade genomic model evaluation, many arising from subtle data leakage or inappropriate evaluation protocols.</p>
<p>Test set overlap with pretraining data creates artificial inflation of transfer learning performance. Foundation models trained on massive corpora may inadvertently include sequences later used for evaluation. When evaluating models on “held-out” data that actually appeared during pretraining, the model has seen the answers. Verifying that test sequences were excluded from pretraining corpora requires careful provenance tracking.</p>
<p>Temporal leakage uses future information unavailable at prediction time. Evaluating a variant pathogenicity model on variants annotated after the training data was collected creates an unrealistically favorable setting. Temporal splits, where the model sees only variants discovered before a cutoff and is evaluated on variants discovered afterward, provide more realistic assessment.</p>
<p>Inappropriate baselines inflate apparent transfer learning benefits. Comparing adapted foundation models against weak or poorly-tuned from-scratch baselines makes transfer look more valuable than it is. Strong baselines, including properly hyperparameter-tuned models trained on the same target data, provide fair comparisons.</p>
<p>Reporting confidence intervals from multiple training runs reveals performance variability. A single training run may produce misleadingly good or bad results. Testing on multiple datasets rather than a single benchmark reveals whether gains generalize. Failure case analysis, examining where and why the model errs, often reveals more about model behavior than aggregate metrics.</p>
</section>
<section id="emerging-directions" class="level2" data-number="9.13">
<h2 data-number="9.13" class="anchored" data-anchor-id="emerging-directions"><span class="header-section-number">9.13</span> Emerging Directions</h2>
<p>Transfer learning continues evolving, with several directions particularly relevant to genomic applications.</p>
<p>In-context learning, where models make predictions by conditioning on examples provided in the input context, has emerged as a powerful capability in very large language models. Early evidence suggests that sufficiently large genomic models may exhibit similar behavior, performing tasks by observing a few examples without explicit fine-tuning. This could transform deployment: rather than training adapters or fine-tuning, users would simply provide examples of desired behavior.</p>
<p>Test-time adaptation updates models during inference based on characteristics of test examples. Rather than freezing models after training, test-time adaptation allows limited parameter updates to match deployment conditions. This approach handles distribution shift without requiring labeled target data.</p>
<p>Federated learning enables collaborative training across institutions without sharing raw data, addressing privacy constraints that limit data pooling in clinical genomics. Institutions train local models on private data and share only aggregated updates. This could enable foundation models trained on far more diverse data than any single institution can access.</p>
<p>Better theory for predicting when transfer will succeed based on measurable source and target properties would reduce trial-and-error. Currently, practitioners must empirically test whether transfer helps; theoretical guidance could focus effort on promising combinations.</p>
</section>
<section id="practical-guidelines" class="level2" data-number="9.14">
<h2 data-number="9.14" class="anchored" data-anchor-id="practical-guidelines"><span class="header-section-number">9.14</span> Practical Guidelines</h2>
<p>Transfer learning bridges pretrained models and specific applications, balancing adaptation flexibility against computational cost and overfitting risk. Several key principles emerge from this chapter.</p>
<p>Match adaptation strategy to available data. With fewer than 1,000 examples, feature extraction is safest. With 1,000 to 10,000 examples, PEFT methods balance expressiveness and regularization. With more than 10,000 examples, consider full fine-tuning but compare against simpler baselines.</p>
<p>Validate that transfer helps. Compare adapted models against from-scratch baselines trained on the same target data. Without this comparison, the value of pretrained models cannot be established. Sometimes training from scratch performs equivalently or better.</p>
<p>Consider domain shift. Models trained in one context may fail silently in another. Explicit domain adaptation and careful out-of-distribution evaluation help identify and mitigate these risks.</p>
<p>Start simple and increase complexity as needed. Linear probes train quickly and often prove surprisingly effective. Invest in more complex adaptation only when simpler approaches demonstrably fail.</p>
<p>Use probing to diagnose representations before committing to adaptation strategies. Understanding what features the pretrained model encodes guides choices about whether frozen features will suffice or whether more aggressive adaptation is needed.</p>
<p>These guidelines connect to later chapters examining specific foundation model families. DNA language models (<a href="p3-ch11-dna-lm.html" class="quarto-xref"><span>Chapter 11</span></a>), protein language models (<a href="p3-ch12-protein-lm.html" class="quarto-xref"><span>Chapter 12</span></a>), and regulatory models (<a href="p3-ch13-regulatory.html" class="quarto-xref"><span>Chapter 13</span></a>) each present characteristic transfer learning patterns. Variant effect prediction (<a href="p3-ch14-vep-fm.html" class="quarto-xref"><span>Chapter 14</span></a>) synthesizes transfer across modalities. The evaluation principles in <a href="p5-ch21-eval.html" class="quarto-xref"><span>Chapter 21</span></a> and confounding considerations in <a href="p5-ch22-confounding.html" class="quarto-xref"><span>Chapter 22</span></a> further inform validation of transfer learning claims. Throughout, the core message persists: transfer learning is powerful but not automatic. Understanding when and how to adapt pretrained models separates effective practitioners from those who treat foundation models as black boxes.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./p2-ch08-pretraining.html" class="pagination-link" aria-label="Pretraining Objectives and Strategies">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Pretraining Objectives and Strategies</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./p3--architectures.html" class="pagination-link" aria-label="Part III: Deep Learning Architectures">
        <span class="nav-page-text">Part III: Deep Learning Architectures</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2025, Josh Meehl</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>